fn main[T, U, V](x: i32, y: i32)
    let x: u64 = 5
    const PI: f64 = 3.14
    let y = 10
    let x: &i32 = 10
    let z: *u32 = 345
    mut z = "Jello?"
    let x: *raw = 389
    let msg: string = "Hello world!"
    let special = $"Hello {23}!"
    io.println(msg)

fn add(a: i32, b: i32) -> i32
    let something = a + (b / 10) == 10
    $"Result is {a.add(b)::C}"

fn! Vector2.add(a: &i32)
    self.x += a
    self.y += a

struct Ref[T]
    ptr: *const T

struct MutRef[T]
    ptr: *T

fn Something::upper_the_string(ref: Ref[string]) -> string
    ref.to_uppercase()

fn some_string[T]() -> string
    where
        T: Display
        U: Ord + Clone + Hash
    $"Hello {10}!"

fn nop() -> ok
    pass

let x = 10

type Integer = i32
type DoubleRaw = **raw
type Array[T] = SomeOther[T]
type Vector2::Alpine = i32

enum[u8] Dog
    requires
        Display
        Debug
    BULLFOG = 0
    POODLE = 10
    BEAGLE = 20

enum[u8] Dog::Color
    BLACK = 0
    BROWN
    WHITE = 2

union std::Either[U, V]
    requires
        Display
        Debug
    Left: U
    Right: V

struct Vector[T]
    arr: []T
    len: usize

packed struct Bits
    a: u8
    b: u16
    c: u32

interface Drawable[T]
    extends
        Display
        Debug
    fn draw() -> ok
    fn resize(width: T, height: T) -> ok

interface Iterator[T]
    fn next() -> Option[T]

const HELLO_THERE = true

namespace Hello
    pass

let x = 10
